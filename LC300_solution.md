# #LC300 最长递增子序列(Longest Increasing Subsequence)

## 题目描述：
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

1 <= nums.length <= 2500, $-10^4$ <= nums[i] <= $10^4$

## 思路一：暴力回溯
在思考一道题的没有头绪时可以首先尝试思考如何**暴力解题**(bushi)。本题需要在字符串中找到某一符合要求的子列，于是朴素的思路是**穷举所有的可能子列**，然后再逐一判定所选子列是否满足要求。

从集合中穷举所有子列的方法是采用**回溯法**(具体如何实现我相信之后会有题目介绍，这里就不展开详细讲了)。在穷举每种子列时，**每个元素有被选择或不被选择两种情况**，因此穷举总时间复杂度为$O(2^n)$。又对每个子列，判定是否为递增和记录其长度总共需要$O(n)$的时间，因此暴力回溯的总时间复杂度为$O(n \cdot 2^n)$。

$O(n \cdot 2^n)$的时间复杂度对$10^4$的数据量来说显然是不可接受的，但是它为我们打开了思路。

## 思路二：动态规划
优化回溯法的指数时间复杂度的方法通常有**剪枝**和**动态规划**(这题剪枝显然不太现实……)。动态规划通过利用之前状态的信息，**将回溯法的树状结构优化成线性结构**，从而大大减少了时间复杂度。

考虑用动态规划解题时，需要确定**维度，状态和转移方程**。本题是一道经典的字符串动态规划问题，沿着之前回溯的思路思考，我们不难想到将维度确定为**数组的长度**，状态确定为**每种长度下的最长递增子序列**。此时，我们可以思考状态方程的构造：

每一次增加数组长度都新填进了一个元素，我们需要根据新添的元素和之前记录下来的状态来确定当前状态。一种朴素的想法是遍历所有之前的记录，**比较新加入的元素和记录中递增子序列的最末尾元素的大小**，整合成新的递增子序列，然后再从所有的这些递增子序列中选出最大的一个。该算法的总时间复杂度为$O(n^2)$，较之之前的回溯大大优化。不过由于每次都需要保存递增子序列，空间复杂度也达到了$O(n^2)$。

我们可以进一步优化该方法。本题中所求的问题是递增子序列的长度，我们自然可以想到将状态改为每种长度下的最长递增子序列长度，这样就可以使用$O(n)$的空间完成该题。这看上去是可行的，因为本质上我们每次比较时都**只用到了递增子序列的末尾元素这一个元素**。但是如果每次保存的是最长递增子序列长度的话，我们无法得到在该数组长度下最长递增子序列的末尾元素，因为我们每次只能访问**当前数组的最末尾元素**。故我们需要给状态加一个限定，将其限制为**以当前元素结尾的**最长递增子序列的长度。在加了这一限定以后，由于我们还是需要遍历之前的所有记录，而我们需要的最优递增子列**一定会以之前的某一个元素结尾**，所以在这种情况下我们也不会将最优情况遗漏。在动态规划结束后，不要忘记我们记录下来的是有限制的最长递增子列长度，要遍历一遍所有记录将最大值输出。

**代码(C++)**
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = (int)nums.size();
        if (n == 0) {
            return 0;
        }
        vector<int> dp(n, 0);
        for (int i = 0; i < n; ++i) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

## 思路三：贪心+二分查找

这一思路比较难想，它来自于这一朴素的贪心想法：如果我们要使上升子序列尽可能的长，则我们需要**让序列上升得尽可能慢**，因此我们希望**每次在上升子序列最后加上的那个数尽可能的小**。

对于一个数组而言，其某一长度的最长上升子序列可能不只有一个(如56781234)。从思路二中，我们已经得到经验：递增子序列中只有末尾元素是重要的，它决定在新加入元素时该序列是否能够变长。因此在贪心时我们仍然希望记录递增子序列的末尾元素，只不过这次是记录**长度为 i 的最长上升子序列的末尾元素的最小值**。这个数组d[i]有一个重要重要的性质：**d[i]是单调递增的**。因为如果d[j] < d[i]且j > i的话，那么对d[j]所对应的递增子列去掉j-i个元素，得到的仍然是递增子列，且得到的d'[i] < d[i],产生了矛盾，故d[i]必然是单调递增的。

接下来，对每一个新元素，我们仍然需要将其去与历史记录对比：如果它比最长的递增子序列末尾元素大，那么我们就得到了一个更长的递增子序列。否则该元素就**必然可以作为某一更短递增子序列的末尾**，我们可以在d[i]这一有序数组中用二分法找到位置并且更新它的末尾元素。遍历数组后的d[i]的长度即为最长递增子序列的长度。该算法时间复杂度只有$O(nlogn)$，空间复杂度只有$O(n)$。

**代码**
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> LIS_tail(n, 0);
        LIS_tail[0] = nums[0];
        int length = 1;

        for (int i = 1; i < n; i++) {
            if (nums[i] > LIS_tail[length - 1]) {
                LIS_tail[++length - 1] = (nums[i]);
            } else {
                int left = 0;
                int right = length - 1;

                while(left <= right) {
                    int mid = (left + right) >> 1;
                    if (LIS_tail[mid] == nums[i]) {
                        left = mid;
                        break;
                    } else if (LIS_tail[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                LIS_tail[left] = nums[i];
            }
        }

        return length;
    }
};
```

## 总结
最长递增子序列(Longest Increasing Subsequence)是一道非常经典非常高频的面试题，它经常最为原型被其它题目转化(如#354 俄罗斯套娃信封问题)。建议熟记此题的dp解法和二分解法(如果记得住的话)，在转化时要能熟练地将其写出。
